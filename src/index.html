<!DOCTYPE html><html lang="en"><head><title>src/index</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="src/index"><meta name="groc-project-path" content="src/index.ls"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">src/index.ls</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="monad-maybea">Monad: Maybe(a)</h1>

<p>A Monad for values that may not be present, or computations that may
fail. <code>Maybe(a)</code> explicitly models the effects that are implicit in
<code>Nullable</code> types, thus has none of the problems associated with <code>null</code>
or <code>undefined</code> — like <code>NullPointerExceptions</code>.</p></div></div></div><div class="segment"><div class="code folded"><div class="wrapper marker"><span class="c1">/** </span></div><div class="wrapper"><span class="cm">/** </span>
<span class="cm"> * Copyright (c) 2013 Quildreen &quot;Sorella&quot; Motta &lt;quildreen@gmail.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person</span>
<span class="cm"> * obtaining a copy of this software and associated documentation files</span>
<span class="cm"> * (the &quot;Software&quot;), to deal in the Software without restriction,</span>
<span class="cm"> * including without limitation the rights to use, copy, modify, merge,</span>
<span class="cm"> * publish, distribute, sublicense, and/or sell copies of the Software,</span>
<span class="cm"> * and to permit persons to whom the Software is furnished to do so,</span>
<span class="cm"> * subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice shall be</span>
<span class="cm"> * included in all copies or substantial portions of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE</span>
<span class="cm"> * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION</span>
<span class="cm"> * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION</span>
<span class="cm"> * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> * + module: monads.maybe</span>
<span class="cm"> * + author: Quildreen Motta</span>
<span class="cm"> * + exports: Maybe</span>
<span class="cm"> */</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The class models two different cases:</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li><code>Just a</code> — represents a <code>Maybe(a)</code> that contains a value. <code>a</code> may be
any value, including <code>null</code> or <code>undefined</code>.</li>
<li><code>Nothing</code> — represents a <code>Maybe(a)</code> that has no values. Or a
failure that needs no additional information.</li>
</ul></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Common uses of this monad includes modelling values that may or may
not be present in a collection, thus instead of needing a
<code>collection.has(a)</code>, the <code>collection.get(a)</code> operation gives you all
the information you need — <code>collection.get(a).is-nothing</code> being
equivalent to <code>collection.has(a)</code>; Similarly the same reasoning may be
applied to computations that may fail to provide a value, e.g.:
<code>collection.find(predicate)</code> can safely return a <code>Maybe(a)</code> instance,
even if the collection contains nullable values.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Furthermore, the values of <code>Maybe(a)</code> can be combined and manipulated
by using the expressive monadic operations. This allows safely
sequencing operations that may fail, and safely composing values that
you don't know whether they're present or not, failing early
(returning a <code>Nothing</code>) if any of the operations fail.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If one wants to store additional information about failures, the
[Either][] and [Validation][] monads provide such a capability, and
should be used instead of the <code>Maybe(a)</code> monad.</p></div></div></div><div class="segment"></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="class-maybea">Class: Maybe(a)</h2>

<p>The <code>Maybe(a)</code> monad.</p></div></div><div class="code"><div class="wrapper"><span class="k">class</span> <span class="nx">Maybe</span>
  <span class="nf">-&gt;</span>
 </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="section-constructors">Section: Constructors</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-nothing">Function: Nothing</h4>

<p>Constructs a new <code>Maybe(a)</code> monad with an absent value — i.e.:
represents a failure.</p>

<ul>
<li>type: Unit -> Maybe(a)</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">Nothing: </span><span class="nf">-&gt;</span> <span class="nx">Nothing</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-just">Function: Just</h4>

<p>Constructs a new <code>Maybe(a)</code> monad that holds the single value <code>a</code>.
<code>a</code> can be any value, including <code>null</code>, <code>undefined</code> or another
<code>Maybe(a)</code> monad.</p>

<ul>
<li>type: a -> Maybe(a)</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">Just: </span><span class="nf">(a) -&gt;</span> <span class="k">new</span> <span class="nx">Just</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-from-nullable">Function: from-nullable</h4>

<p>Constructs a new <code>Maybe(a)</code> monad from a nullable type. If the value
is either <code>null</code> or <code>undefined</code>, this function returns a <code>Nothing</code>,
otherwise the value is wrapped in a <code>Just(a)</code>.</p>

<ul>
<li>type: a -> Maybe(a)</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">from-nullable: </span><span class="nf">(a) -&gt;</span>
    <span class="o">|</span> <span class="nx">a</span><span class="o">?</span> <span class="o">=&gt;</span> <span class="nx">Nothing</span>
    <span class="o">|</span> <span class="nx">_</span>  <span class="o">=&gt;</span> <span class="k">new</span> <span class="nx">Just</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="section-predicates">Section: Predicates</h3></div></div><div class="code"><div class="wrapper">  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="field-is-nothing">Field: is-nothing</h4>

<p>True if the <code>Maybe(a)</code> monad contains a failure (i.e.: <code>Nothing</code>).</p>

<ul>
<li>type: Boolean</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="o">is-</span><span class="nv">nothing: </span><span class="kc">false</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="field-is-just">Field: is-just</h4>

<p>True if the <code>Maybe(a)</code> monad contains a single value (i.e.:
<code>Just(a)</code>).</p>

<ul>
<li>type: Boolean</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="o">is-</span><span class="nv">just: </span><span class="kc">false</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="section-applicative">Section: Applicative</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-of">Function: of</h4>

<p>Creates a new <code>Maybe(a)</code> monad holding the single value <code>a</code>.</p>

<p><code>a</code> can be any value, includding <code>null</code>, <code>undefined</code> or another
<code>Maybe(a)</code> monad.</p>

<ul>
<li>type: a -> Maybe(a)</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="k">of</span><span class="o">:</span> <span class="nf">(a) -&gt;</span> <span class="k">new</span> <span class="nx">Just</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-ap">Function: ap</h4>

<p>Applies the function inside the <code>Maybe(a)</code> monad to another
applicative type.</p>

<p>The <code>Maybe(a)</code> monad should contain a function value, otherwise a
<code>TypeError</code> is thrown.</p>

<ul>
<li>type: (@Maybe(a -> b), f:Applicative) => f(a) -> f(b)</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">ap: </span><span class="nf">(_) -&gt;</span> <span class="p">...</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="section-functor">Section: Functor</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-map">Function: map</h4>

<p>Transforms the value of the <code>Maybe(a)</code> monad using a regular unary
function.</p>

<ul>
<li>type: (@Maybe(a)) => (a -> b) -> Maybe(b)</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">map: </span><span class="nf">(_) -&gt;</span> <span class="p">...</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="section-chain">Section: Chain</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-chain">Function: chain</h4>

<p>Transforms the value of the <code>Maybe(a)</code> monad using an unary function
to a monad of the same type.</p>

<ul>
<li>type: (@Maybe(a)) => (a -> Maybe(b)) -> Maybe(b)</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">chain: </span><span class="nf">(_) -&gt;</span> <span class="p">...</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="section-show">Section: Show</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-to-string">Function: to-string</h4>

<p>Returns a textual representation of the <code>Maybe(a)</code> monad.</p>

<ul>
<li>type: Unit -> String</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="k">to</span><span class="o">-</span><span class="nv">string: </span><span class="nf">-&gt;</span> <span class="p">...</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="section-eq">Section: Eq</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-is-equal">Function: is-equal</h4>

<p>Tests if a <code>Maybe(a)</code> monad is equal to another <code>Maybe(a)</code> monad.</p>

<ul>
<li>type: (@Maybe(a)) => Maybe(a) -> Boolean</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="o">is-</span><span class="nv">equal: </span><span class="nf">(_) -&gt;</span> <span class="p">...</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="section-extracting-and-recovering">Section: Extracting and Recovering</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-get">Function: get</h4>

<p>Extracts the value out of the <code>Maybe(a)</code> monad, if it
exists. Otherwise throws a <code>TypeError</code>.</p>

<ul>
<li>see: get-or-else — A getter that can handle failures.</li>
<li>type: (@Maybe(a), *throws) -> a</li>
<li>throws: TypeError — if the monad has no value (<code>Nothing</code>).</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">get: </span><span class="nf">-&gt;</span> <span class="p">...</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-get-or-else">Function: get-or-else</h4>

<p>Extracts the value out of the <code>Maybe(a)</code> monad. If there is no
value, returns the given default.</p>

<ul>
<li>type: (@Maybe(a)) -> a -> a</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">get-or-else: </span><span class="nf">(_) -&gt;</span> <span class="p">...</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-or-else">Function: or-else</h4>

<p>Transforms a failure into a new <code>Maybe(a)</code> monad. Does nothing if
the monad already contains a value.</p>

<ul>
<li>type: (@Maybe(a)) -> (Unit -> Maybe(a)) -> Maybe(a)</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="o">or-</span><span class="k">else</span><span class="o">:</span> <span class="nf">(_) -&gt;</span> <span class="p">...</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="class-justa">Class: Just(a)</h2>

<p>Represents a <code>Maybe(a)</code> holding a value.</p></div></div><div class="code"><div class="wrapper"><span class="k">class</span> <span class="nx">Just</span> <span class="k">extends</span> <span class="nx">Maybe</span>
  <span class="nf">(@value) -&gt;</span>
  <span class="o">is-</span><span class="nv">just: </span><span class="kc">true</span>
  <span class="nv">ap: </span><span class="nf">(b) -&gt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">map</span> <span class="nx">@value</span>
  <span class="nv">map: </span><span class="nf">(f) -&gt;</span> <span class="nx">@</span><span class="k">of</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">@value</span><span class="p">)</span>
  <span class="nv">chain: </span><span class="nf">(f) -&gt;</span> <span class="nx">f</span> <span class="nx">@value</span>
  <span class="k">to</span><span class="o">-</span><span class="nv">string: </span><span class="nf">-&gt;</span> <span class="s">&quot;Maybe.Just(</span><span class="si">#{</span><span class="nx">@value</span><span class="si">}</span><span class="s">)&quot;</span>
  <span class="o">is-</span><span class="nv">equal: </span><span class="nf">(a) -&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">is-just</span> <span class="o">and</span> <span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">value</span> <span class="o">is</span> <span class="nx">@value</span><span class="p">)</span>
  <span class="nv">get: </span><span class="nf">-&gt;</span> <span class="nx">@value</span>
  <span class="nv">get-or-else: </span><span class="nf">(a) -&gt;</span> <span class="nx">@value</span>
  <span class="o">or-</span><span class="k">else</span><span class="o">:</span> <span class="nf">-&gt;</span> <span class="k">this</span>
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="object-nothing">Object: Nothing</h2>

<p>A singleton representing a <code>Maybe(a)</code> holding no value.</p></div></div><div class="code"><div class="wrapper"><span class="nv">Nothing = </span><span class="k">new</span> <span class="k">class</span> <span class="k">extends</span> <span class="nx">Maybe</span>
  <span class="nf">-&gt;</span>
  <span class="o">is-</span><span class="nv">nothing: </span><span class="kc">true</span>
  <span class="nv">ap: </span><span class="nf">(b) -&gt;</span> <span class="nx">b</span>
  <span class="nv">map: </span><span class="nf">(f) -&gt;</span> <span class="k">this</span>
  <span class="nv">chain: </span><span class="nf">(f) -&gt;</span> <span class="k">this</span>
  <span class="k">to</span><span class="o">-</span><span class="nv">string: </span><span class="nf">-&gt;</span> <span class="s">&quot;Maybe.Nothing&quot;</span>
  <span class="o">is-</span><span class="nv">equal: </span><span class="nf">(a) -&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">is-nothing</span>
  <span class="nv">get: </span><span class="nf">-&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s">&quot;Can&#39;t extract the value of a Nothing&quot;</span><span class="p">)</span>
  <span class="nv">get-or-else: </span><span class="nf">(a) -&gt;</span> <span class="nx">a</span>
  <span class="o">or-</span><span class="k">else</span><span class="o">:</span> <span class="nf">(f) -&gt;</span> <span class="nx">f</span><span class="o">!</span>
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="exports">Exports</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper"><span class="nv">module.exports = </span><span class="k">new</span> <span class="nx">Maybe</span></div></div></div></div></body></html>